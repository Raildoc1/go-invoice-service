// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/services/messages-dispatcher.go
//
// Generated by this command:
//
//	mockgen -source=./internal/services/messages-dispatcher.go -destination=./internal/services/mocks/mock_messages-dispatcher.go
//

// Package mock_services is a generated GoMock package.
package mock_services

import (
	context "context"
	reflect "reflect"
	dto "validation-service/internal/dto"

	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockInvoiceValidator is a mock of InvoiceValidator interface.
type MockInvoiceValidator struct {
	ctrl     *gomock.Controller
	recorder *MockInvoiceValidatorMockRecorder
	isgomock struct{}
}

// MockInvoiceValidatorMockRecorder is the mock recorder for MockInvoiceValidator.
type MockInvoiceValidatorMockRecorder struct {
	mock *MockInvoiceValidator
}

// NewMockInvoiceValidator creates a new mock instance.
func NewMockInvoiceValidator(ctrl *gomock.Controller) *MockInvoiceValidator {
	mock := &MockInvoiceValidator{ctrl: ctrl}
	mock.recorder = &MockInvoiceValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInvoiceValidator) EXPECT() *MockInvoiceValidatorMockRecorder {
	return m.recorder
}

// Validate mocks base method.
func (m *MockInvoiceValidator) Validate(arg0 *dto.Invoice) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Validate", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Validate indicates an expected call of Validate.
func (mr *MockInvoiceValidatorMockRecorder) Validate(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validate", reflect.TypeOf((*MockInvoiceValidator)(nil).Validate), arg0)
}

// MockInvoiceStorage is a mock of InvoiceStorage interface.
type MockInvoiceStorage struct {
	ctrl     *gomock.Controller
	recorder *MockInvoiceStorageMockRecorder
	isgomock struct{}
}

// MockInvoiceStorageMockRecorder is the mock recorder for MockInvoiceStorage.
type MockInvoiceStorageMockRecorder struct {
	mock *MockInvoiceStorage
}

// NewMockInvoiceStorage creates a new mock instance.
func NewMockInvoiceStorage(ctrl *gomock.Controller) *MockInvoiceStorage {
	mock := &MockInvoiceStorage{ctrl: ctrl}
	mock.recorder = &MockInvoiceStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInvoiceStorage) EXPECT() *MockInvoiceStorageMockRecorder {
	return m.recorder
}

// GetInvoice mocks base method.
func (m *MockInvoiceStorage) GetInvoice(ctx context.Context, id uuid.UUID) (*dto.Invoice, dto.InvoiceStatus, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInvoice", ctx, id)
	ret0, _ := ret[0].(*dto.Invoice)
	ret1, _ := ret[1].(dto.InvoiceStatus)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetInvoice indicates an expected call of GetInvoice.
func (mr *MockInvoiceStorageMockRecorder) GetInvoice(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInvoice", reflect.TypeOf((*MockInvoiceStorage)(nil).GetInvoice), ctx, id)
}

// SetApproved mocks base method.
func (m *MockInvoiceStorage) SetApproved(ctx context.Context, id uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApproved", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApproved indicates an expected call of SetApproved.
func (mr *MockInvoiceStorageMockRecorder) SetApproved(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApproved", reflect.TypeOf((*MockInvoiceStorage)(nil).SetApproved), ctx, id)
}

// SetRejected mocks base method.
func (m *MockInvoiceStorage) SetRejected(ctx context.Context, id uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRejected", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRejected indicates an expected call of SetRejected.
func (mr *MockInvoiceStorageMockRecorder) SetRejected(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRejected", reflect.TypeOf((*MockInvoiceStorage)(nil).SetRejected), ctx, id)
}

// MockMessageConsumer is a mock of MessageConsumer interface.
type MockMessageConsumer struct {
	ctrl     *gomock.Controller
	recorder *MockMessageConsumerMockRecorder
	isgomock struct{}
}

// MockMessageConsumerMockRecorder is the mock recorder for MockMessageConsumer.
type MockMessageConsumerMockRecorder struct {
	mock *MockMessageConsumer
}

// NewMockMessageConsumer creates a new mock instance.
func NewMockMessageConsumer(ctrl *gomock.Controller) *MockMessageConsumer {
	mock := &MockMessageConsumer{ctrl: ctrl}
	mock.recorder = &MockMessageConsumerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMessageConsumer) EXPECT() *MockMessageConsumerMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockMessageConsumer) Commit(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockMessageConsumerMockRecorder) Commit(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockMessageConsumer)(nil).Commit), ctx)
}

// ErrIsNoMessage mocks base method.
func (m *MockMessageConsumer) ErrIsNoMessage(arg0 error) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ErrIsNoMessage", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ErrIsNoMessage indicates an expected call of ErrIsNoMessage.
func (mr *MockMessageConsumerMockRecorder) ErrIsNoMessage(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ErrIsNoMessage", reflect.TypeOf((*MockMessageConsumer)(nil).ErrIsNoMessage), arg0)
}

// PeekNext mocks base method.
func (m *MockMessageConsumer) PeekNext(pollTimeoutMs int) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeekNext", pollTimeoutMs)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PeekNext indicates an expected call of PeekNext.
func (mr *MockMessageConsumerMockRecorder) PeekNext(pollTimeoutMs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeekNext", reflect.TypeOf((*MockMessageConsumer)(nil).PeekNext), pollTimeoutMs)
}
